// = Your Blog title
// See https://hubpress.gitbooks.io/hubpress-knowledgebase/content/ for information about the parameters.
// :hp-image: /covers/cover.png
// :published_at: 2019-01-31
// :hp-tags: HubPress, Blog, Open_Source,
// :hp-alt-title: My English Title

:stem: latexmath

= Learning to reconstruct

Suppose that you were given a blurred image:

image::mayo_convolved.png[mayo_convolved, height=300, width=300]

Then you could probably tell that it was generated from this image:

image:mayo_phantom.png[mayo_phantom, height=300, width=300]

But what about if I instead gave you the line integrals of the image:

image:mayo_data.png[mayo_data, height=300, width=300]

Would you still tell it came from the image above? Probably not. But we will demonstrate how we can teach a computer to do it.

== Introduction

Both of the above problems can be stated in the mathematical framework of inverse problems. In inverse problem we seek to find (reconstruct) some parameters given indirect observations. Mathematically this can be stated as finding some parameters stem:[f] that are connected to measured data stem:[g] through the _forward model_ stem:[\mathcal{T}]:

[stem]
+++++++++++++++++
g = \mathcal{T}(f) + noise
+++++++++++++++++

Several classical image processing problems such as denoising, inpainting, deblurring and superresolution can be cast into this form, but it is also a good model for more complicated problems such as Computed Tomography (CT), Magnetic Resonance Imaging (MRI), etc.

== Machine learning for inverse problems

If stem:[\mathcal{T}] maps images to images, such as the convolution above, finding the unknown parameters from data using machine learning is at least on a conceptual level straightforward, and any standard convolutional architecture could be used to learn a transformation from stem:[g] to stem:[f]. Simply give the neural network stem:[g] as input and train it to find stem:[f].

But what happens when stem:[\mathcal{T}] is more complicated? 
We'll focus on CT, where the forward model is given by the https://en.wikipedia.org/wiki/Radon_transform[Radon transform] which computes all line integrals of the image:

[stem]
+++++++++++++++++
\mathcal{T}(f)(\ell) = \int_{\ell} f(x) dx  \quad \ell \text{ is a line in } \mathbb{R}^2
+++++++++++++++++

If we compare this to the deblurring problem, we see that while the blurring problem has a local relationship between parameters and data, the radon transform has a global relationship. Here two widely separated points can both influence a point in data as long as they lie on the same line. And since the forward model is global, so is the inverse problem. This means that classical local machine-learning approaches based on convolutions will not work.

One way to solve this would be to use fully-connected layers instead of convolutions, but this quickly becomes infeasible. For example, in the example a single fully connected layer between data and signal would require a staggering stem:[2.6 \cdot 10^{11}] weights. Storing these in single precision would require one terabyte of data. For a single layer. 

This is obviously not a workable solution.

== Learned denoisers

One of the most obvious solutions to this problem is to somehow re-cast the problem back into a image-to-image problem. The most popular way of doing this is to first do some initial reconstruction, e.g. https://en.wikipedia.org/wiki/Radon_transform#Radon_inversion_formula[Filtered Back-Projection] (FBP):

video::mayo_fbp_animation.mp4[mayo_fbp_animation, height=309, width=700, options="autoplay,loop"]

Once this has been applied, we can use any standard machine-learning approach to "denoise" the initial reconstruction by training a neural network to take the initial reconstruction as input and return the ground truth.

Several groups have done this and the results are in fact quite remarkable:

image:learned_denoiser.png[mayo_data, height=309, width=800]

However, the method leaves a sour after-taste. Sure the images certainly look better, but the only input was the initial reconstruction, so could it truly show anything that wasn't already there?

== Learned Primal-Dual

This observation leads to a painful conclusion: in order to get a reconstruction that contains more information than current reconstruction methods, we _need_ to work directly from raw data. But as we noted above, fully learning how to do this is practically impossible.

The solution is to take a middle way, to incorporate enough a-priori information  to make the problem tractable and then learn the rest.

The most powerful prior information we have is the forward operator stem:[\mathcal{T}], but it only maps images to data, how would we go from data to reconstruction? One answer is to use the https://en.wikipedia.org/wiki/Hermitian_adjoint[adjoint operator] stem:[\mathcal{T}^*].

The idea of our proposed model is to use these operators alternatively. First we use a neural network to update the data (a so called *dual* step), then apply stem:[\mathcal{T}^*] to this and use it as input to a neural network which updates the reconstruction (the *primal* step), then apply stem:[\mathcal{T}] and use it as input to a neural network that updates the data, and so on. This is iteratively performed a fixed number of times (10 in our experiments), at which point we have a final reconstruction. We train this end-to-end, with raw data as input and the reconstruction as output.

The good thing about this is that we separate the global aspect of the problem into the forward model and its adjoint and only need to learn the local aspects. The bad thing is that to train the network we need to perform back-propagation through this neural network that among others contain 10 calls to the forward operator, 10 calls the the adjoint operator and 20 small neural networks in between. We did this using some magic with https://github.com/odlgroup/odl[Operator Discretization Library] and TensorFlow.

== Results

If you ask me, the results look quite good and I especially appreciate that the method is able to avoid some artifacts (shown with red arrows) that the denoiser just wasn't able to remove:

image:compare_results_anotated.png[compare_results_anotated, height=700, width=800]

The quantitative results are also quite cool and we outperform learned denoising w.r.t both Peak Signal to Noise Ratio https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio[(PSNR)] and structural similarity index https://en.wikipedia.org/wiki/Structural_similarity[(SSIM)]. The runtime is not too shabby either and we manage to do all of this using only stem:[2\%] parameters used for the denoiser.

[width="100%", height="60%", frame="topbot",cols="8,2,2,2,2",options="header"]
|======================
|Method | PSNR | SSIM | Runtime | Parameters
|FBP        | 33.65 |  0.830 | 423  | 1
|Learned Denoiser        | 41.92 | 0.941 | 463 | stem:[10^7]
|Learned Primal-Dual        | *44.11* | *0.969* | 620 | stem:[2.4 \cdot 10^5]
|======================

== Read more

If you found this interesting you could read our article "Learned Primal-Dual Reconstruction" on https://arxiv.org/abs/1707.06474[ArXiv], where we describe the method in depth and give a broader overview of what others have done in this exciting field. You could also throw an eye on the https://github.com/adler-j/learned_primal_dual[source code].